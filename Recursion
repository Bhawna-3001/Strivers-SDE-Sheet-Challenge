Because we have to find combinations and not max or min
if max or min----------then dp lagta

# sum of all subsets
class Solution{
    private void subseq(int ind,int n,ArrayList<Integer> l,ArrayList<Integer> arr,ArrayList<Integer> ds){
        if(ind==n){
            int sum=0;
            for(int i=0;i<ds.size();i++){
                sum+=ds.get(i);
            }
            l.add(sum);
            return;
        }
        ds.add(arr.get(ind));
        subseq(ind+1,n,l,arr,ds);
        ds.remove(ds.size()-1);
        subseq(ind+1,n,l,arr,ds);
    }
    ArrayList<Integer> subsetSums(ArrayList<Integer> arr, int n){
        // code here
        ArrayList<Integer> l=new ArrayList<>();
        subseq(0,n,l,arr,new ArrayList<>());
        return l;
    }
}

Time: O(2^n)+O(2^n log(2^n)). Each index has two ways. You can either pick it up or not pick it.
So for n index time complexity for O(2^n) and for sorting it will take (2^n log(2^n)).
_______________________________________________________________________________
#find unique subsets

  class Solution {
    private void subseq(int ind,int n,List<List<Integer>> arr,int nums[],List<Integer> ds){
        if(ind==n){
            List<Integer> l=new ArrayList<>(ds);
            Collections.sort(l);
            if(!arr.contains(l)){
                arr.add(l);
            }
            return;
        }
        ds.add(nums[ind]);
        subseq(ind+1,n,arr,nums,ds);
        ds.remove(ds.size()-1);
        subseq(ind+1,n,arr,nums,ds);
    }
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> arr=new ArrayList<>();
        int n=nums.length;
        subseq(0,n,arr,nums,new ArrayList<>());
        return arr;
    }
}
time: O(k*2^n)
_________________________________________
# find unique subsets having a sum k

class Solution {
    private void comb(int ind,int[] arr,int target,List<List<Integer>> ans,List<Integer> ds){
        if (ind==arr.length){
            if (target==0){
                ans.add(new ArrayList<>(ds));
            }  
            return;
        }
        
        if(arr[ind]<=target){
            ds.add(arr[ind]);
            comb(ind,arr,target-arr[ind],ans,ds);
            ds.remove(ds.size()-1);
        }
        comb(ind+1,arr,target,ans,ds);
    }
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans=new ArrayList<>();
        comb(0,candidates,target,ans,new ArrayList<>());
        return ans;
    }
}
time: O(2^t * k)
